#!/usr/bin/env ruby
#

require 'optparse'

opts = OptionParser.new
opts.banner = <<EOS
Usage: #{opts.program_name}

Process a single e-mail message in plain-text/MIME format (.eml) from
STDIN and act on it by converting and storing attachments, for example,
or start an interactive debugging session with pry-rescue for unmached
mail and any other failures.  To be called on individual messages from
Mutt, for example.

EOS

opts.separator "Options:"

options = {}

opts.on '-i', '--interactive', "permit user interactions" do
  options[:interactive] = true
end

opts.on '-n', '--noop', "dry-run to show what would be done" do
  options[:noop] = true
end

opts.parse!

if ARGV.size != 0
  opts.fail "wrong # arguments (try --help)"
end

# Use uninstalled sources when started from the source directory.
if libdir = File.expand_path('../../lib', __FILE__) and
  File.file? "#{libdir}/monkey/process_mail.rb"

  $LOAD_PATH.unshift libdir
end

require 'pry-rescue'

require 'monkey/process_mail'

[:interactive, :noop].each do |option|
  Monkey::ProcessMail.config.send("#{option}=", options[option])
end

# Create a special Mailman application which reads a single message
# from STDIN and then re-opens STDIN from the controlling terminal
# before processing it.
app = Monkey::ProcessMail::Application.new do
  # Evaluage all route providers do define the application's routes.
  instance_eval(&Monkey::ProcessMail::TimeRecording)

  # Specify the default behaviour for unmatched messages.
  default do
    raise "umatched message"
  end
end

# Run the application.
if options[:interactive]
  # Let me debug failed expectations and other application errors.
  Pry.rescue { app.run }
else
  app.run
end
